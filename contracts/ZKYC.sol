// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.0;

import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "./interfaces/IVerifier.sol";
import "./MerkleTreeWithHistory.sol";
import "./interfaces/IZKYC.sol";

//
//  _______                    _    _                   _          _                _     _           _              ______ _       _    _
// (_______)                  | |  / )                 | |        | |              | |   | |         | |    _       / _____) |     | |  | |
//    __    ____  ____ ___    | | / / ____   ___  _ _ _| | ____ _ | | ____  ____   | |___| |___  ____| | _ | |_    | /     | |_   _| | _| |
//   / /   / _  )/ ___) _ \   | |< < |  _ \ / _ \| | | | |/ _  ) || |/ _  |/ _  )   \_____/ _  |/ ___) || \|  _)   | |     | | | | | || \_|
//  / /___( (/ /| |  | |_| |  | | \ \| | | | |_| | | | | ( (/ ( (_| ( ( | ( (/ /      ___( ( | ( (___| | | | |__   | \_____| | |_| | |_) )
// (_______)____)_|   \___/   |_|  \_)_| |_|\___/ \____|_|\____)____|\_|| |\____)    (___)\_||_|\____)_| |_|\___)   \______)_|\____|____/_|
//                                                                 (_____|
//
//   Zero Knowledge Yacht Club
//   - We don't know who invite you, But one of us must have invited you.
//   - it's enough. Welcome to ZKYC!
contract ZKYC is ERC721Upgradeable, MerkleTreeWithHistory, IZKYC {

    IVerifier private verifier;
    uint256 public MAX_INVITATIONS = 2;
    mapping(address => uint256) public numToInvite;
    mapping(bytes32 => bool) public nullifierHashes;
    uint256 public totalSupply;

    // @param _hasher poseidon hash function
    // @param _verifier merkletree verifier contract generated by snarkjs
    function initialize(
        address _hasher,
        address _verifier,
        bytes32[] memory invitations
    ) external initializer {
        verifier = IVerifier(_verifier);

        __merkleTree_init("ZKYC", 10, _hasher);
        __ERC721_init("Zero Knowledge Yacht Club", "ZKYC");

        for (uint256 i = 0; i < invitations.length; i++) {
            _insert(invitations[i]);
        }
    }

    // @notice The person receiving the invitation must prove that they have the invitation by proof.
    function join(InvitationLetter calldata letter) external {
        require(!nullifierHashes[letter.nullifierHash], "This invitation has been already used");
        require(isKnownRoot(letter.root), "can't find your merkle root");
        require(!isMember(msg.sender), "already invites");
        require(verifier.verifyProof(
                letter.proof.a,
                letter.proof.b,
                letter.proof.c,
                [
                uint256(letter.root),
                uint256(letter.nullifierHash),
                addressToUInt256(msg.sender)
                ]
            ), "invalid proof");

        nullifierHashes[letter.nullifierHash] = true;
        totalSupply += 1;
        _safeMint(msg.sender, totalSupply);

        emit Join(msg.sender, letter.nullifierHash);
    }

    /// @notice Members must create `invitation` before inviting new members.
    ///         invitationCode = poseidonHash(invitation, 0)
    function invite(bytes32 invitationCode) external {
        require(isMember(msg.sender), "msg.sender isn't our member");
        require(numToInvite[msg.sender] < MAX_INVITATIONS, "exceed maximum invitation");

        _insert(invitationCode);
        numToInvite[msg.sender] += 1;

        emit Invitation(msg.sender, invitationCode);
    }

    function _beforeTokenTransfer(address from, address, uint256, uint256) internal override pure {
        // @dev block to transfer
        require(from == address(0), "your address is already soul-bounded.");
    }

    function totalInvitations() external view returns (uint256) {
        return leafs.length;
    }

    function invitation(uint256 index) external view returns (bytes32) {
        return leafs[index];
    }

    function isMember(address member) public view returns (bool) {
        return balanceOf(member) > 0;
    }

    function addressToUInt256(address adr) internal pure returns (uint256) {
        return uint256(uint160(adr));
    }
}
